RESULT_ROOT = 'results'

from string import Template
import re
import os



#### PARSING ####
def load_course( path, **kwargs ):

    def course(path='src'):
        entity = 'course'
        course_mode = 'Course Creator'  # Course Creator | Study
        # name
        last_dir = path.lower().split('/')[-1]
        if last_dir == 'src': name = 'Demo'
        else:  name = last_dir.title()
        description = 'autogenerated by https://github.com/dz0/pyCharmEDU_course_creation_helpers'

        files = os.listdir(path)
        files = [os.path.join( path, f ) for f in files]
        files = [f  for f in files if os.path.isfile(f) and f.endswith('.py') ]
        children = lessons = map(lesson, files)
        return locals()

    def lesson(path):
        entity = 'lesson'
        name = os.path.split( path )[-1]   [:-len('.py')]
        name = name.replace("_", " ").title()
        code = open(path).read()

        task_codes = code.split("###TASK:")
        intro = task_codes.pop(0)

        children = tasks = map(task, task_codes)
        return locals()

    def task(task_code):
        entity = 'task'
        lines = task_code.split("\n")
        name = lines.pop(0)

        children = placeholders = []
        student_lines = []
        for nr, line in enumerate(lines):
            if line.strip() == "###GROUP_LINES":
                line = ""
                while nr < len(lines)-1:
                    next = lines.pop(nr+1)
                    if next.strip() == "###GROUP_LINES_END":
                        break
                    line += '\n'+ next
            p = placeholder( line )

            if p['match']:
                placeholders.append( p )
                lines[nr] = p['result_code']
                p['line_nr'] = nr

                line_4student = lines[nr].replace( p['expected'], p['given'] ) # insert student stuff...
            else:
                line_4student = line

            student_lines.append( line_4student )

        result_code  = '\n'.join( lines )
        student_code = '\n'.join( student_lines )


        return locals()

    # def subtask():
        # pass

    def placeholder(code):
        """analyze code for placeholder directive"""
        entity = 'placeholder'
        re_placeholder = re.compile(r"###PLACEHOLDER:(.*?)--\>(.+)" , re.DOTALL)

        # in **multiline** separate directive from code
        directive_parts = []
        clean_code = []
        for line in code.split('\n'):
           if '###' in line:
               line, directive_part = line.split("###", 1)
               directive_parts.append( directive_part.rstrip() )
           clean_code.append( line.rstrip() )
        directive = "###" + '\n'.join(directive_parts)
        result_code = "\n".join(clean_code)


        match = re_placeholder.search(directive)
        # match = re_placeholder.search(code)
        if match:
            expected, given = match.group(1).strip(), match.group(2).strip() # todo: maybe implement nonstrip option -- for indentation questions
            if expected=="":  # shortcut when we want to replace all # looks like: ###PLACEHOLDER:-->sth...
                expected = result_code
            # result_code = re.sub(re_placeholder, "", result_code)  # clear directive from code
            offset_in_line = result_code.find( expected )
            # result_line_OKanswered = result_line.replace( expected, given )

        return locals()

    result = course( path )
    result.update( kwargs )
    return result


#### RENDERING ####
def escapeXMLText(text):
    text = text.replace("&", "&amp;")
    text = text.replace("\"", "&quot;")
    text = text.replace("'", "&apos;")
    text = text.replace("<", "&lt;")
    text = text.replace(">", "&gt;")
    text = text.replace("\n", "&#10;")
    return text

def study_project_decorator(info):
    """escape some xml strings"""
    # info = info.copy()  # maybe -- not to override initial vals
    for key, val in info.items():
        if key in "name description given expected code_html_escaped".split():
            info[key] = escapeXMLText(val)
    return info


def render_with_children( info , templates, decorator=None ):
    if info['entity'] != 'placeholder':
        rendered_children_list = [render_with_children(child, templates, decorator)       for child in info['children'] ]
        # rendered_children_list = map( lambda x: render_with_children(x, templates),  info['children'] )
        info['rendered_children'] = "\n".join( rendered_children_list )  # recursion

    if decorator:
        info = decorator(info)

    tpl =  templates[ info['entity']  ]
    result = tpl.safe_substitute( info )

    return result

def save(fname, content, dirpath=""):
    dirpath = os.path.join( RESULT_ROOT, dirpath )
    if not os.path.exists(dirpath):
        os.makedirs(dirpath)

    if isinstance( content, (list, tuple)):
        content = "\n".join( content )  # try to be smart

    with open( os.path.join( dirpath, fname), 'w') as f:
        f.write( content )


def render_course_tree( info ):
    # for course in info:
        course = info
        for lnr, lesson in enumerate( course['children'] ):
            # print (lnr)
            lesson['nr'] = lnr+1
            
            for tnr, task in enumerate ( lesson['children'] ):
                # make_test_file(path=path, human_nr=nr+1, name=name, expected=expected, extra_args="")
                # print("  ", tnr )
                task['nr'] = tnr+1
                
                # task['code_html_escaped'] = ...
                for phnr, placeholder in enumerate( task['children'] ):
                    # print("    ", phnr)
                    placeholder.setdefault('extra_args', '')
                    placeholder['nr'] = phnr
                    placeholder['human_nr'] = phnr+1

                    # placeholder offset and length NEEDED for study_project.xml
                    def placeholder_offset(lines):
                        """lines -- task[ 'lines' or 'student_lines' ]"""
                        lines_before = lines [:  placeholder['line_nr'] ]
                        lines_before.insert(0, lesson['intro'] )
                        lines_before.append(  placeholder['result_code'] [ : placeholder['offset_in_line'] ] )
                        content_before = "\n".join( lines_before )
                        return len( content_before ) # todo fixme: now only for one placeholder per line


                    placeholder['offset'] = placeholder_offset( task['lines'] )
                    placeholder['length'] = len(placeholder['given'])

                    placeholder['student_offset'] = placeholder_offset( task['student_lines'] )

                    # placeholder['student_length'] = len(placeholder['given'])

                    print ( ' -> '.join( map(str,   [ lesson.get('name'), task.get('name'), placeholder.get('given') ] )))


                dirpath = path = os.path.join("lesson%s" % lesson['nr'],
                                              "task%s" % task['nr']   )
                tests_content = render_with_children( task , templates=tests_tpls  )
                # for creator
                save('tests.py', tests_content , dirpath='creator/'+dirpath )
                save('task.py', lesson['intro']+"\n"+task['result_code'] , dirpath='creator/'+dirpath )
                # for student
                save('tests.py', tests_content , dirpath='student/'+dirpath )
                task_student_code = task['student_code']
                save('task.py', lesson['intro']+"\n"+task_student_code , dirpath='student/'+dirpath )


def load_templates(target):
    ext = os.path.splitext(target)[1][1:].strip().lower()  # or pathlib
    templates = {}
    for fname in os.listdir('tpl/'+target):
        # if fname.endswith("."+ext):
            entity = fname[:-len(ext)-1]
            templates[entity] = Template(open(os.path.join("tpl", target, fname)).read())

    return templates


def study_project_convert_creator2student():
    stuff = open(RESULT_ROOT+'/creator'+'/study_project.xml').read()

    for lesson in course['children']:
        for task in lesson['children']:
            if len(task['children'])>1:  # if more than 1 placeholder -- the offsets for student might change
                for ph in task['children']:
                    # print ("PH offsets:", ph['nr'], ph['offset'] , ph['student_offset'])
                    ph_content_creator = render_with_children(ph, study_project_templates, study_project_decorator)
                    ph['offset'] = ph['student_offset']  # override for student
                    ph_content_student = render_with_children(ph, study_project_templates, study_project_decorator)
                    stuff = stuff.replace(ph_content_creator, ph_content_student)

    stuff = stuff.replace( '<option name="courseMode" value="Course Creator" />',
                           '<option name="courseMode" value="Study" />' )

    stuff = stuff.replace( '<option name="useLength" value="false" />',
                           '<option name="useLength" value="true" />')
    save('student/study_project.xml', stuff)

def _main():
    global  course
    course = info = load_course("src/idioms")
    from pprint import pprint
    pprint(info)

    # TEST course files tree rendering: task.py , test.py
    global tests_tpls
    tests_tpls = load_templates('tests.py')

    render_course_tree(info)

    # TEST study_project rendering
    global study_project_templates
    study_project_templates = load_templates('study_project.xml')
    # study_project_templates = {}
    # for fname in os.listdir('tpl/study_project.xml'):
    #     if fname.endswith(".xml"):
    #         study_project_templates[fname[:-4]] = Template(open(os.path.join("tpl/study_project", fname)).read())

    content = render_with_children(info, study_project_templates, study_project_decorator)
    save("study_project.xml", content, dirpath='creator/')

    possibly_unsubstituted = re.findall(r"\$\w+" , content)  # check for sake of carefullness
    print("== possibly_unsubstituted ==")
    print(set(possibly_unsubstituted) )

    study_project_convert_creator2student()



    # TODO move files to new place...
    print("OK")


if __name__ == "__main__":
    _main()
